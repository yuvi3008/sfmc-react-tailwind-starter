import {
  AsYouType,
  InputBasic_default,
  InputSmart_default,
  formatPhoneNumber,
  formatPhoneNumberIntl,
  getCountries,
  getCountryCallingCode,
  getInternationalPhoneNumberPrefix,
  isPossiblePhoneNumber,
  isSupportedCountry,
  isValidPhoneNumber,
  metadata,
  metadata_min_json_default,
  parseDigits,
  parsePhoneNumber,
  removePrefixFromFormattedPhoneNumber,
  require_prop_types,
  validateE164Number
} from "./chunk-32SXGB3V.js";
import {
  require_react
} from "./chunk-RUPNRBO7.js";
import {
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/react-phone-number-input/modules/PhoneInputBrowser.js
var import_react3 = __toESM(require_react(), 1);
var import_prop_types2 = __toESM(require_prop_types(), 1);

// node_modules/react-phone-number-input/modules/PhoneInput.js
var import_react2 = __toESM(require_react(), 1);
var import_prop_types = __toESM(require_prop_types(), 1);

// node_modules/react-phone-number-input/modules/usePhoneDigits.js
var import_react = __toESM(require_react(), 1);
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function usePhoneDigits(_ref) {
  var _this = this;
  var value = _ref.value, onChange = _ref.onChange, country = _ref.country, defaultCountry = _ref.defaultCountry, international = _ref.international, withCountryCallingCode = _ref.withCountryCallingCode, useNationalFormatForDefaultCountryValue = _ref.useNationalFormatForDefaultCountryValue, metadata2 = _ref.metadata;
  if (typeof withCountryCallingCode === "boolean" && !(country && international)) {
    console.error("[react-phone-number-input] `withCountryCallingCode` property can only be used together with `country` and `international` properties");
  }
  if (country && defaultCountry) {
    console.error("[react-phone-number-input] When `country` property is passed, `defaultCountry` property has no effect and therefore shouldn't be passed");
  }
  if (typeof international === "boolean" && !country) {
    console.error("[react-phone-number-input] `international` property can only be used together with `country` property");
  }
  var inputFormat = getInputFormat({
    international,
    country,
    defaultCountry,
    withCountryCallingCode
  });
  var countryMismatchDetected = (0, import_react.useRef)();
  var onCountryMismatch = function onCountryMismatch2(value2, country2, actualCountry) {
    console.error("[react-phone-number-input] Expected phone number ".concat(value2, " to correspond to country ").concat(country2, " but ").concat(actualCountry ? "in reality it corresponds to country " + actualCountry : "it doesn't", "."));
    countryMismatchDetected.current = true;
  };
  var getInitialPhoneDigits = function getInitialPhoneDigits2(options) {
    if (value) {
      validateE164Number(value);
    }
    return getPhoneDigitsForValue(value, country, defaultCountry, inputFormat, useNationalFormatForDefaultCountryValue, metadata2, function() {
      if (options && options.onCountryMismatch) {
        options.onCountryMismatch();
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      onCountryMismatch.apply(_this, args);
    });
  };
  var _useState = (0, import_react.useState)(country), _useState2 = _slicedToArray(_useState, 2), prevCountry = _useState2[0], setPrevCountry = _useState2[1];
  var _useState3 = (0, import_react.useState)(defaultCountry), _useState4 = _slicedToArray(_useState3, 2), prevDefaultCountry = _useState4[0], setPrevDefaultCountry = _useState4[1];
  var _useState5 = (0, import_react.useState)(getInitialPhoneDigits()), _useState6 = _slicedToArray(_useState5, 2), phoneDigits = _useState6[0], setPhoneDigits = _useState6[1];
  var _useState7 = (0, import_react.useState)(value), _useState8 = _slicedToArray(_useState7, 2), valueForPhoneDigits = _useState8[0], setValueForPhoneDigits = _useState8[1];
  var _useState9 = (0, import_react.useState)(), _useState10 = _slicedToArray(_useState9, 2), rerenderTrigger = _useState10[0], setRerenderTrigger = _useState10[1];
  var rerender = (0, import_react.useCallback)(function() {
    return setRerenderTrigger({});
  }, [setRerenderTrigger]);
  function getValueForPhoneDigits(phoneDigits2) {
    if (!phoneDigits2) {
      return;
    }
    if (inputFormat === "NATIONAL_PART_OF_INTERNATIONAL") {
      phoneDigits2 = "+".concat(getCountryCallingCode(country, metadata2)).concat(phoneDigits2);
    }
    var asYouType = new AsYouType(country || defaultCountry, metadata2);
    asYouType.input(phoneDigits2);
    return asYouType.getNumberValue();
  }
  (0, import_react.useEffect)(function() {
    if (value !== valueForPhoneDigits) {
      setValueForPhoneDigits(value);
      setPhoneDigits(getInitialPhoneDigits());
    }
  }, [value]);
  (0, import_react.useEffect)(function() {
    if (country !== prevCountry) {
      setPrevCountry(country);
      var _countryMismatchDetected;
      var _phoneDigits = getInitialPhoneDigits({
        onCountryMismatch: function onCountryMismatch2() {
          _countryMismatchDetected = true;
        }
      });
      setPhoneDigits(_phoneDigits);
      if (_countryMismatchDetected) {
        setValueForPhoneDigits(getValueForPhoneDigits(_phoneDigits));
      }
    }
  }, [country]);
  (0, import_react.useEffect)(function() {
    if (defaultCountry !== prevDefaultCountry) {
      setPrevDefaultCountry(defaultCountry);
      setPhoneDigits(getInitialPhoneDigits());
    }
  }, [defaultCountry]);
  (0, import_react.useEffect)(function() {
    if (valueForPhoneDigits !== value) {
      onChange(valueForPhoneDigits);
    }
  }, [valueForPhoneDigits]);
  var onSetPhoneDigits = (0, import_react.useCallback)(function(phoneDigits2) {
    var value2;
    if (country) {
      if (inputFormat === "INTERNATIONAL") {
        var prefix = getInternationalPhoneNumberPrefix(country, metadata2);
        if (phoneDigits2.indexOf(prefix) !== 0) {
          if (phoneDigits2 && phoneDigits2[0] !== "+") {
            phoneDigits2 = prefix + phoneDigits2;
          } else {
            if (countryMismatchDetected.current) {
            } else {
              setPhoneDigits(prefix);
              setValueForPhoneDigits(void 0);
              return rerender();
            }
          }
        }
      } else {
        if (phoneDigits2 && phoneDigits2[0] === "+") {
          phoneDigits2 = phoneDigits2.slice(1);
        }
      }
    } else if (!defaultCountry) {
      if (phoneDigits2 && phoneDigits2[0] !== "+") {
        phoneDigits2 = "+" + phoneDigits2;
      }
    }
    if (phoneDigits2) {
      value2 = getValueForPhoneDigits(phoneDigits2);
    }
    setPhoneDigits(phoneDigits2);
    setValueForPhoneDigits(value2);
  }, [country, inputFormat, defaultCountry, metadata2, setPhoneDigits, setValueForPhoneDigits, rerender, countryMismatchDetected]);
  return {
    phoneDigits,
    setPhoneDigits: onSetPhoneDigits,
    inputFormat
  };
}
function getPhoneDigitsForValue(value, country, defaultCountry, inputFormat, useNationalFormatForDefaultCountryValue, metadata2, onCountryMismatch) {
  if (country && inputFormat === "INTERNATIONAL") {
    var prefix = getInternationalPhoneNumberPrefix(country, metadata2);
    if (value) {
      if (value.indexOf(prefix) !== 0) {
        onCountryMismatch(value, country);
      }
      return value;
    }
    return prefix;
  }
  if (!value) {
    return "";
  }
  if (!country && !defaultCountry) {
    return value;
  }
  var asYouType = new AsYouType(void 0, metadata2);
  asYouType.input(value);
  var phoneNumber = asYouType.getNumber();
  if (phoneNumber) {
    if (country) {
      if (phoneNumber.country && phoneNumber.country !== country) {
        onCountryMismatch(value, country, phoneNumber.country);
      } else if (phoneNumber.countryCallingCode !== getCountryCallingCode(country, metadata2)) {
        onCountryMismatch(value, country);
      }
      switch (inputFormat) {
        case "NATIONAL":
          return parseDigits(phoneNumber.formatNational());
        case "NATIONAL_PART_OF_INTERNATIONAL":
          return parseDigits(removePrefixFromFormattedPhoneNumber(phoneNumber.formatInternational(), getInternationalPhoneNumberPrefix(country, metadata2)));
        case "INTERNATIONAL":
          throw new Error('`inputFormat: "INTERNATIONAL"` case should\'ve already been handled earlier in the code');
        case "INTERNATIONAL_OR_NATIONAL":
          throw new Error('`inputFormat: "INTERNATIONAL_OR_NATIONAL"` is not possible when `country` is fixed');
        default:
          throw new Error("Unknown `inputFormat`: ".concat(inputFormat));
      }
    } else {
      if (phoneNumber.countryCallingCode && phoneNumber.countryCallingCode === getCountryCallingCode(defaultCountry, metadata2) && useNationalFormatForDefaultCountryValue) {
        return parseDigits(phoneNumber.formatNational());
      }
      return value;
    }
  } else {
    return "";
  }
}
function getInputFormat(_ref2) {
  var international = _ref2.international, country = _ref2.country, defaultCountry = _ref2.defaultCountry, withCountryCallingCode = _ref2.withCountryCallingCode;
  return country ? international ? withCountryCallingCode ? "INTERNATIONAL" : "NATIONAL_PART_OF_INTERNATIONAL" : "NATIONAL" : defaultCountry ? "INTERNATIONAL_OR_NATIONAL" : "INTERNATIONAL";
}

// node_modules/react-phone-number-input/modules/PhoneInput.js
var _excluded = ["Component", "country", "defaultCountry", "useNationalFormatForDefaultCountryValue", "value", "onChange", "metadata", "international", "withCountryCallingCode"];
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function PhoneInput(_ref, ref) {
  var Component = _ref.Component, country = _ref.country, defaultCountry = _ref.defaultCountry, _ref$useNationalForma = _ref.useNationalFormatForDefaultCountryValue, useNationalFormatForDefaultCountryValue = _ref$useNationalForma === void 0 ? true : _ref$useNationalForma, value = _ref.value, onChange = _ref.onChange, metadata2 = _ref.metadata, international = _ref.international, withCountryCallingCode = _ref.withCountryCallingCode, rest = _objectWithoutProperties(_ref, _excluded);
  var _usePhoneDigits = usePhoneDigits({
    value,
    onChange,
    country,
    defaultCountry,
    international,
    withCountryCallingCode,
    useNationalFormatForDefaultCountryValue,
    metadata: metadata2
  }), phoneDigits = _usePhoneDigits.phoneDigits, setPhoneDigits = _usePhoneDigits.setPhoneDigits, inputFormat = _usePhoneDigits.inputFormat;
  return import_react2.default.createElement(Component, _extends({}, rest, {
    ref,
    metadata: metadata2,
    inputFormat,
    international,
    withCountryCallingCode,
    country: country || defaultCountry,
    value: phoneDigits,
    onChange: setPhoneDigits
  }));
}
PhoneInput = import_react2.default.forwardRef(PhoneInput);
PhoneInput.propTypes = {
  /**
   * The phone number (in E.164 format).
   * Examples: `"+12"`, `"+12133734253"`.
   * An "empty" `value` could be represented by any "falsy" value like `undefined`, `null` or an empty string `""`.
   */
  value: import_prop_types.default.string,
  /**
   * A function of `value: string?`.
   * Updates the `value` property (to `undefined` in case it's empty).
   */
  onChange: import_prop_types.default.func.isRequired,
  /**
   * A two-letter country code for formatting `value`
   * as a national phone number (example: `(213) 373-4253`),
   * or as an international phone number without "country calling code"
   * if `international` property is passed (example: `213 373 4253`).
   * Example: "US".
   * If no `country` is passed then `value`
   * is formatted as an international phone number.
   * (example: `+1 213 373 4253`)
   */
  country: import_prop_types.default.string,
  /**
   * A two-letter country code for formatting `value`
   * when a user inputs a national phone number (example: `(213) 373-4253`).
   * The user can still input a phone number in international format.
   * Example: "US".
   * `country` and `defaultCountry` properties are mutually exclusive.
   */
  defaultCountry: import_prop_types.default.string,
  /**
   * If `country` property is passed along with `international={true}` property
   * then the phone number will be input in "international" format for that `country`
   * (without "country calling code").
   * For example, if `country="US"` property is passed to "without country select" input
   * then the phone number will be input in the "national" format for `US` (`(213) 373-4253`).
   * But if both `country="US"` and `international={true}` properties are passed then
   * the phone number will be input in the "international" format for `US` (`213 373 4253`)
   * (without "country calling code" `+1`).
   */
  international: import_prop_types.default.bool,
  /**
   * If `country` and `international` properties are set,
   * then by default it won't include "country calling code" in the input field.
   * To change that, pass `withCountryCallingCode` property,
   * and it will include "country calling code" in the input field.
   */
  withCountryCallingCode: import_prop_types.default.bool,
  /**
   * A component that renders the `<input/>` itself and also
   * parses and formats its `value` as the user inputs it.
   * See `InputBasic.js` and `InputSmart.js` for an example.
   */
  Component: import_prop_types.default.elementType.isRequired,
  /**
   * When `defaultCountry` is defined and the initial `value` corresponds to `defaultCountry`,
   * then the `value` will be formatted as a national phone number by default.
   * To format the initial `value` of `defaultCountry` as an international number instead
   * set `useNationalFormatForDefaultCountryValue` property to `true`.
   */
  useNationalFormatForDefaultCountryValue: import_prop_types.default.bool,
  /**
   * `libphonenumber-js` metadata.
   */
  metadata
};
var PhoneInput_default = PhoneInput;

// node_modules/react-phone-number-input/modules/PhoneInputBrowser.js
var _excluded2 = ["type", "autoComplete", "smartCaret", "metadata"];
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _objectWithoutProperties2(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose2(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function createInput(defaultMetadata) {
  function PhoneInput2(_ref, ref) {
    var _ref$type = _ref.type, type = _ref$type === void 0 ? "tel" : _ref$type, _ref$autoComplete = _ref.autoComplete, autoComplete = _ref$autoComplete === void 0 ? "tel" : _ref$autoComplete, _ref$smartCaret = _ref.smartCaret, smartCaret = _ref$smartCaret === void 0 ? true : _ref$smartCaret, _ref$metadata = _ref.metadata, metadata2 = _ref$metadata === void 0 ? defaultMetadata : _ref$metadata, rest = _objectWithoutProperties2(_ref, _excluded2);
    return import_react3.default.createElement(PhoneInput_default, _extends2({}, rest, {
      type,
      autoComplete,
      metadata: metadata2,
      ref,
      Component: smartCaret ? InputSmart_default : InputBasic_default
    }));
  }
  PhoneInput2 = import_react3.default.forwardRef(PhoneInput2);
  PhoneInput2.propTypes = {
    /**
     * HTML `<input/>` `type` attribute.
     */
    type: import_prop_types2.default.string,
    /**
     * HTML `<input/>` `autocomplete` attribute.
     */
    autoComplete: import_prop_types2.default.string,
    /**
     * By default, the caret position is being "intelligently" managed
     * while a user inputs a phone number.
     * This "smart" caret behavior can be turned off
     * by passing `smartCaret={false}` property.
     * This is just an "escape hatch" for any possible caret position issues.
     */
    // Is `true` by default.
    smartCaret: import_prop_types2.default.bool,
    /**
     * `libphonenumber-js` metadata.
     */
    metadata: import_prop_types2.default.object
  };
  return PhoneInput2;
}
var PhoneInputBrowser_default = createInput();

// node_modules/react-phone-number-input/input/index.js
function call(func, _arguments) {
  var args = Array.prototype.slice.call(_arguments);
  args.push(metadata_min_json_default);
  return func.apply(this, args);
}
var input_default = createInput(metadata_min_json_default);
function parsePhoneNumber2() {
  return call(parsePhoneNumber, arguments);
}
function formatPhoneNumber2() {
  return call(formatPhoneNumber, arguments);
}
function formatPhoneNumberIntl2() {
  return call(formatPhoneNumberIntl, arguments);
}
function isValidPhoneNumber2() {
  return call(isValidPhoneNumber, arguments);
}
function isPossiblePhoneNumber2() {
  return call(isPossiblePhoneNumber, arguments);
}
function getCountries2() {
  return call(getCountries, arguments);
}
function getCountryCallingCode2() {
  return call(getCountryCallingCode, arguments);
}
function isSupportedCountry2() {
  return call(isSupportedCountry, arguments);
}
export {
  input_default as default,
  formatPhoneNumber2 as formatPhoneNumber,
  formatPhoneNumberIntl2 as formatPhoneNumberIntl,
  getCountries2 as getCountries,
  getCountryCallingCode2 as getCountryCallingCode,
  isPossiblePhoneNumber2 as isPossiblePhoneNumber,
  isSupportedCountry2 as isSupportedCountry,
  isValidPhoneNumber2 as isValidPhoneNumber,
  parsePhoneNumber2 as parsePhoneNumber
};
//# sourceMappingURL=react-phone-number-input_input.js.map
