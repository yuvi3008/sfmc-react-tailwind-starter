{"version":3,"file":"templateFormatter.js","names":["count_occurences","close_braces","template","placeholder","shouldCloseBraces","value","text","placeholdersCountInTemplate","characterIndexInValue","templateWithFilledInPlaceholders","split","character","length"],"sources":["../source/templateFormatter.js"],"sourcesContent":["import { count_occurences } from './helpers.js'\r\nimport close_braces from './closeBraces.js'\r\n\r\n// Takes a `template` where character placeholders\r\n// are denoted by 'x'es (e.g. 'x (xxx) xxx-xx-xx').\r\n//\r\n// Returns a function which takes `value` characters\r\n// and returns the `template` filled with those characters.\r\n// If the `template` can only be partially filled\r\n// then it is cut off.\r\n//\r\n// If `shouldCloseBraces` is `true`,\r\n// then it will also make sure all dangling braces are closed,\r\n// e.g. \"8 (8\" -> \"8 (8  )\" (iPhone style phone number input).\r\n//\r\nexport default function(template, placeholder = 'x', shouldCloseBraces) {\r\n\tif (!template) {\r\n\t\treturn value => ({ text: value })\r\n\t}\r\n\r\n\tconst placeholdersCountInTemplate = count_occurences(placeholder, template)\r\n\r\n\treturn function(value) {\r\n\t\tif (!value) {\r\n\t\t\treturn { text: '', template }\r\n\t\t}\r\n\r\n\t\tlet characterIndexInValue = 0\r\n\t\tlet templateWithFilledInPlaceholders = ''\r\n\r\n\t\t// Using `.split('')` here instead of normal `for ... of`\r\n\t\t// because the importing application doesn't neccessarily include an ES6 polyfill.\r\n\t\t// The `.split('')` approach discards \"exotic\" UTF-8 characters\r\n\t\t// (the ones consisting of four bytes)\r\n\t\t// but template placeholder characters don't fall into that range\r\n\t\t// and appending UTF-8 characters to a string in parts still works.\r\n\t\tfor (const character of template.split('')) {\r\n\t\t\tif (character !== placeholder) {\r\n\t\t\t\ttemplateWithFilledInPlaceholders += character\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\ttemplateWithFilledInPlaceholders += value[characterIndexInValue]\r\n\t\t\tcharacterIndexInValue++\r\n\r\n\t\t\t// If the last available value character has been filled in,\r\n\t\t\t// then return the filled in template\r\n\t\t\t// (either trim the right part or retain it,\r\n\t\t\t//  if no more character placeholders in there)\r\n\t\t\tif (characterIndexInValue === value.length) {\r\n\t\t\t\t// If there are more character placeholders\r\n\t\t\t\t// in the right part of the template\r\n\t\t\t\t// then simply trim it.\r\n\t\t\t\tif (value.length < placeholdersCountInTemplate) {\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (shouldCloseBraces) {\r\n\t\t\ttemplateWithFilledInPlaceholders = close_braces(templateWithFilledInPlaceholders, template)\r\n\t\t}\r\n\r\n\t\treturn { text: templateWithFilledInPlaceholders, template }\r\n\t}\r\n}"],"mappings":";;;;;;AAAA,SAASA,gBAAT,QAAiC,cAAjC;AACA,OAAOC,YAAP,MAAyB,kBAAzB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,UAASC,QAAT,EAAyD;EAAA,IAAtCC,WAAsC,uEAAxB,GAAwB;EAAA,IAAnBC,iBAAmB;;EACvE,IAAI,CAACF,QAAL,EAAe;IACd,OAAO,UAAAG,KAAK;MAAA,OAAK;QAAEC,IAAI,EAAED;MAAR,CAAL;IAAA,CAAZ;EACA;;EAED,IAAME,2BAA2B,GAAGP,gBAAgB,CAACG,WAAD,EAAcD,QAAd,CAApD;EAEA,OAAO,UAASG,KAAT,EAAgB;IACtB,IAAI,CAACA,KAAL,EAAY;MACX,OAAO;QAAEC,IAAI,EAAE,EAAR;QAAYJ,QAAQ,EAARA;MAAZ,CAAP;IACA;;IAED,IAAIM,qBAAqB,GAAG,CAA5B;IACA,IAAIC,gCAAgC,GAAG,EAAvC,CANsB,CAQtB;IACA;IACA;IACA;IACA;IACA;;IACA,qDAAwBP,QAAQ,CAACQ,KAAT,CAAe,EAAf,CAAxB,wCAA4C;MAAA,IAAjCC,SAAiC;;MAC3C,IAAIA,SAAS,KAAKR,WAAlB,EAA+B;QAC9BM,gCAAgC,IAAIE,SAApC;QACA;MACA;;MAEDF,gCAAgC,IAAIJ,KAAK,CAACG,qBAAD,CAAzC;MACAA,qBAAqB,GAPsB,CAS3C;MACA;MACA;MACA;;MACA,IAAIA,qBAAqB,KAAKH,KAAK,CAACO,MAApC,EAA4C;QAC3C;QACA;QACA;QACA,IAAIP,KAAK,CAACO,MAAN,GAAeL,2BAAnB,EAAgD;UAC/C;QACA;MACD;IACD;;IAED,IAAIH,iBAAJ,EAAuB;MACtBK,gCAAgC,GAAGR,YAAY,CAACQ,gCAAD,EAAmCP,QAAnC,CAA/C;IACA;;IAED,OAAO;MAAEI,IAAI,EAAEG,gCAAR;MAA0CP,QAAQ,EAARA;IAA1C,CAAP;EACA,CA1CD;AA2CA"}